# –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞ ‚Ññ1

**–í—ã–ø–æ–ª–Ω–∏–ª:** –ú–∏—Ä–æ–Ω–µ–Ω–∫–æ –ê—Ä—Ç–µ–º –î–º–∏—Ç—Ä–∏–µ–≤–∏—á  
**–ì—Ä—É–ø–ø–∞:** P3331  
**–Ø–∑—ã–∫–∏:** OCaml, Go

---

## –ó–∞–¥–∞—á–∞ 4

**–ù–∞–π—Ç–∏ –Ω–∞–∏–±–æ–ª—å—à–∏–π –ø–∞–ª–∏–Ω–¥—Ä–æ–º, —è–≤–ª—è—é—â–∏–π—Å—è –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º –¥–≤—É—Ö —Ç—Ä—ë—Ö–∑–Ω–∞—á–Ω—ã—Ö —á–∏—Å–µ–ª.**

---

### –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (OCaml)

#### `monolithic_tail`

–ú–æ–Ω–æ–ª–∏—Ç–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å **—Ö–≤–æ—Å—Ç–æ–≤–æ–π —Ä–µ–∫—É—Ä—Å–∏–µ–π**.  
–ù–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è —á–∏—Å–µ–ª `i * j`, –ø—Ä–∏ —ç—Ç–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —à–∞–≥–æ–≤ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä `best`.  
–†–µ–∫—É—Ä—Å–∏—è –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è, –ø–æ–∫–∞ –Ω–µ –ø–µ—Ä–µ–±—Ä–∞–Ω—ã –≤—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ `[min..max]`.  
–ë–ª–∞–≥–æ–¥–∞—Ä—è —Ö–≤–æ—Å—Ç–æ–≤–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–µ —Ä–∞—Å—Ö–æ–¥—É–µ—Ç —Å—Ç–µ–∫ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø–æ –ø–∞–º—è—Ç–∏.

#### `monolithic_recursive`

–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è **—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è** —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ —Ö–≤–æ—Å—Ç–æ–≤–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.  
–î–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ `i` —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –ø–∞–ª–∏–Ω–¥—Ä–æ–º –≤ —Å—Ç—Ä–æ–∫–µ (`check_row`), –∑–∞—Ç–µ–º –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Å–∞–º–∞ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —á–∏—Å–ª–∞.  
–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ–≥–æ –ø–æ–Ω–∏–º–∞–Ω–∏—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –æ–±—Ö–æ–¥–∞, –Ω–æ –Ω–µ –æ–ø—Ç–∏–º–∞–ª—å–Ω–∞ –ø—Ä–∏ –±–æ–ª—å—à–∏—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–∞—Ö.

#### `modular_pipeline`

–ú–æ–¥—É–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è, –∏—Å–ø–æ–ª—å–∑—É—é—â–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä (**–≥–µ–Ω–µ—Ä–∞—Ü–∏—è ‚Üí —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è ‚Üí —Å–≤—ë—Ä—Ç–∫–∞**).  
–ì–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è –≤—Å–µ –ø–∞—Ä—ã —á–∏—Å–µ–ª, —Ñ–∏–ª—å—Ç—Ä—É—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è, –∏ –∏–∑ –Ω–∏—Ö –±–µ—Ä—ë—Ç—Å—è –º–∞–∫—Å–∏–º—É–º.  
–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ **–¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ —Å—Ç–∏–ª—è** –∏ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π (`map`, `filter`, `fold_left`).

#### `map_generation`

–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ø–∞—Ä —á–∏—Å–µ–ª —á–µ—Ä–µ–∑ **map**, —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∏—Ö –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π, –∑–∞—Ç–µ–º —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø—Ä–∏–∑–Ω–∞–∫—É –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞.  
–°–æ—á–µ—Ç–∞–µ—Ç –ø—Ä–æ—Å—Ç–æ—Ç—É –∏ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É—è –ø—Ä–∏–Ω—Ü–∏–ø—ã **—Ä–∞–±–æ—Ç—ã —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞**.

#### `loops_version`

–ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è —á–µ—Ä–µ–∑ **—Ü–∏–∫–ª—ã for**.  
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `best`.  
–≠—Ç–æ—Ç –≤–∞—Ä–∏–∞–Ω—Ç –±–ª–∏–∂–µ –∫ —Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–º —è–∑—ã–∫–∞–º (–Ω–∞–ø—Ä–∏–º–µ—Ä, Go, C), –Ω–æ –º–µ–Ω–µ–µ –∏–¥–∏–æ–º–∞—Ç–∏—á–µ–Ω –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Å—Ç–∏–ª—è.

#### `lazy_seq_version`

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç **–ª–µ–Ω–∏–≤—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏** (`Seq`).  
–°–æ–∑–¥–∞—ë—Ç—Å—è –ø–æ—Ç–æ–∫ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–∞—Ä —á–∏—Å–µ–ª, –¥–∞–ª–µ–µ —Å –ø–æ–º–æ—â—å—é `map` –∏ `filter` –∏–∑ –Ω–µ–≥–æ –∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è –º–∞–∫—Å–∏–º—É–º –ø–∞–ª–∏–Ω–¥—Ä–æ–º–Ω—ã—Ö –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–π.  
–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ ‚Äî –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ö—Ä–∞–Ω–∏—Ç—å –≤–µ—Å—å —Å–ø–∏—Å–æ–∫ –≤ –ø–∞–º—è—Ç–∏, –¥–∞–Ω–Ω—ã–µ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è ¬´–Ω–∞ –ª–µ—Ç—É¬ª.

---

### –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (OCaml, `lib/p04.ml`)

```ocaml
module U = Utils

let largest_palindrome_product ~min ~max =
  let best = ref 0 in
  for i = max downto min do
    for j = i downto min do
      let p = i * j in
      if p > !best && U.is_palindrome p then best := p
    done
  done;
  !best

(* 1) –ú–æ–Ω–æ–ª–∏—Ç–Ω–∞—è —Ö–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è *)
let monolithic_tail ~min ~max =
  let rec inner i j best =
    if i < min then best
    else if j < min then inner (i - 1) (i - 1) best
    else
      let p = i * j in
      let best' = if p > best && U.is_palindrome p then p else best in
      inner i (j - 1) best'
  in
  inner max max 0

(* 2) –ú–æ–Ω–æ–ª–∏—Ç–Ω–∞—è (–Ω–µ—Ö–≤–æ—Å—Ç–æ–≤–∞—è) —Ä–µ–∫—É—Ä—Å–∏—è *)
let monolithic_recursive ~min ~max =
  let rec check_row i j =
    if j < min then 0
    else
      let p = i * j in
      let best_here = if U.is_palindrome p then p else 0 in
      Stdlib.max best_here (check_row i (j - 1))
  in
  let rec rows i =
    if i < min then 0 else Stdlib.max (check_row i i) (rows (i - 1))
  in
  rows max

(* 3) –ú–æ–¥—É–ª—å–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä: generate -> filter -> reduce *)
let modular_pipeline ~min ~max =
  let open List in
  let gen_pairs =
    let acc = ref [] in
    for i = min to max do
      for j = i to max do
        acc := (i, j) :: !acc
      done
    done;
    !acc
  in
  gen_pairs
  |> map (fun (i, j) -> i * j)
  |> filter U.is_palindrome
  |> fold_left Stdlib.max 0

(* 4) –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ map (map -> fold) *)
let map_generation ~min ~max =
  let pairs =
    let acc = ref [] in
    for i = min to max do
      for j = i to max do
        acc := (i, j) :: !acc
      done
    done;
    !acc
  in
  pairs
  |> List.map (fun (i, j) -> i * j)
  |> List.map (fun p -> (p, U.is_palindrome p))
  |> List.fold_left
       (fun b (p, ok) -> if ok && p > b then p else b)
       0

(* 5) –í–∞—Ä–∏–∞–Ω—Ç —Å —Ü–∏–∫–ª–∞–º–∏ *)
let loops_version ~min ~max = largest_palindrome_product ~min ~max

(* 6) –õ–µ–Ω–∏–≤—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ (Seq) *)
let lazy_seq_version ~min ~max =
  let open Seq in
  let range a b = unfold (fun i -> if i > b then None else Some (i, i + 1)) a in
  let pairs =
    range min max
    |> flat_map (fun i -> map (fun j -> (i, j)) (range i max))
  in
  pairs
  |> map (fun (i, j) -> i * j)
  |> filter U.is_palindrome
  |> fold_left Stdlib.max 0

```

---

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è (Go)

–ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π `loops_version` –∏–∑ OCaml.  
–ü–µ—Ä–µ–±–∏—Ä–∞—é—Ç—Å—è –≤—Å–µ –ø–∞—Ä—ã —á–∏—Å–µ–ª, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –ø–∞–ª–∏–Ω–¥—Ä–æ–º–Ω–æ—Å—Ç—å –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è, —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ `best`.  
Go –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ **—Ç—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω–æ–≥–æ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞** –∏ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –ø–∞—Ä–∞–¥–∏–≥–º.

---

#### Go-–≤–µ—Ä—Å–∏—è (`go/p04.go`)

```go
package lib

import "strconv"

func isPalindrome(n int) bool {
	s := strconv.Itoa(n)
	for i := 0; i < len(s)/2; i++ {
		if s[i] != s[len(s)-1-i] {
			return false
		}
	}
	return true
}

func LargestPalindromeProduct(min, max int) int {
	best := 0
	for i := max; i >= min; i-- {
		for j := i; j >= min; j-- {
			p := i * j
			if p > best && isPalindrome(p) {
				best = p
			}
		}
	}
	return best
}
```

---

## –ó–∞–¥–∞—á–∞ 26

**–ù–∞–π—Ç–∏ —á–∏—Å–ª–æ d < 1000, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –ø–µ—Ä–∏–æ–¥ –¥–µ—Å—è—Ç–∏—á–Ω–æ–π –¥—Ä–æ–±–∏ 1/d –∏–º–µ–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É.**

---

### –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (OCaml)

#### `monolithic_tail`

–•–≤–æ—Å—Ç–æ—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è, –∫–æ—Ç–æ—Ä–∞—è –ø–µ—Ä–µ–±–∏—Ä–∞–µ—Ç –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è d –æ—Ç limit‚Äì1 –¥–æ 1, –≤—ã—á–∏—Å–ª—è—è –¥–ª–∏–Ω—É –ø–µ—Ä–∏–æ–¥–∞ (`Utils.recurring_cycle_len`).  
–ê–∫–∫—É–º—É–ª—è—Ç–æ—Ä—ã `best_d` –∏ `best_len` —Ö—Ä–∞–Ω—è—Ç —Ç–µ–∫—É—â–∏–π –º–∞–∫—Å–∏–º—É–º.  
–≠—Ç–æ—Ç –≤–∞—Ä–∏–∞–Ω—Ç –æ–ø—Ç–∏–º–∞–ª–µ–Ω –ø–æ –ø–∞–º—è—Ç–∏.

#### `monolithic_recursive`

–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ —Ö–≤–æ—Å—Ç–æ–≤–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.  
–§—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç —Å–µ–±—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –¥–µ–ª–∏—Ç–µ–ª—è –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–ª–∏–Ω—É –ø–µ—Ä–∏–æ–¥–æ–≤.  
–ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —á–∏—Å—Ç–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏.

#### `modular_pipeline`

–ö–æ–Ω–≤–µ–π–µ—Ä–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ ‚Äî —Å–æ–∑–¥–∞—ë—Ç—Å—è —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–µ–ª–∏—Ç–µ–ª–µ–π, –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –¥–ª–∏–Ω–∞ –ø–µ—Ä–∏–æ–¥–∞, –∞ –∑–∞—Ç–µ–º –±–µ—Ä—ë—Ç—Å—è —ç–ª–µ–º–µ–Ω—Ç —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏–Ω–æ–π.  
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç `List.init`, `map` –∏ `fold_left`, –ø–æ–¥—á—ë—Ä–∫–∏–≤–∞—è **–º–æ–¥—É–ª—å–Ω—ã–π –∏ –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—Ç–∏–ª—å**.

#### `map_generation`

–ü–æ—Ö–æ–∂–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è, –Ω–æ –¥–µ–ª–∞–µ—Ç—Å—è –∞–∫—Ü–µ–Ω—Ç –Ω–∞ **—Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ map/fold**.  
–ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π –∫–∞–∫ –¥–∞–Ω–Ω—ã—Ö.

#### `loops_version`

–ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å —Ü–∏–∫–ª–∞–º–∏ `for`.  
–ü—Ä—è–º–∞—è –∏ –Ω–∞–≥–ª—è–¥–Ω–∞—è, –∞–Ω–∞–ª–æ–≥–∏—á–Ω–∞ –∞–ª–≥–æ—Ä–∏—Ç–º—É –Ω–∞ Go.  
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç –∏–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏ `ref`.

#### `lazy_seq_version`

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç **–ª–µ–Ω–∏–≤—ã–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏** (`Seq`).  
–ü–æ–∑–≤–æ–ª—è–µ—Ç –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –¥–µ–ª–∏—Ç–µ–ª–∏ –±–µ–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–ª–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞.  
–ò–¥–µ–∞–ª—å–Ω–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –±–æ–ª—å—à–∏—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ –±–ª–∞–≥–æ–¥–∞—Ä—è ¬´–ª–µ–Ω–∏–≤–æ–º—É¬ª –≤—ã—á–∏—Å–ª–µ–Ω–∏—é.

---

### –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (OCaml, `lib/p26.ml`)

```ocaml
module U = Utils

let monolithic_tail limit =
  let rec search d best_d best_len =
    if d = 1 then best_d
    else
      let len = U.recurring_cycle_len d in
      if len > best_len then search (d - 1) d len
      else search (d - 1) best_d best_len
  in
  search (limit - 1) 0 0

let monolithic_recursive limit =
  let rec best_to d =
    if d <= 1 then (0, 0)
    else
      let (bd, bl) = best_to (d - 1) in
      let l = U.recurring_cycle_len d in
      if l > bl then (d, l) else (bd, bl)
  in
  fst (best_to (limit - 1))

let modular_pipeline limit =
  List.init (limit - 2) (fun i -> i + 2)
  |> List.map (fun d -> (d, U.recurring_cycle_len d))
  |> List.fold_left (fun (bd, bl) (d, l) -> if l > bl then (d, l) else (bd, bl)) (0, 0)
  |> fst

let map_generation limit =
  List.init (limit - 2) (fun i -> i + 2)
  |> List.map (fun d -> (d, U.recurring_cycle_len d))
  |> List.fold_left (fun (bd, bl) (d, l) -> if l > bl then (d, l) else (bd, bl)) (0, 0)
  |> fst

let loops_version limit =
  let best_d = ref 0 in
  let best_l = ref 0 in
  for d = 2 to limit - 1 do
    let l = U.recurring_cycle_len d in
    if l > !best_l then (best_l := l; best_d := d)
  done;
  !best_d

let lazy_seq_version limit =
  let open Seq in
  let numbers = unfold (fun d -> if d >= limit then None else Some (d, d + 1)) 2 in
  let step (bd, bl) d =
    let l = U.recurring_cycle_len d in
    if l > bl then (d, l) else (bd, bl)
  in
  numbers |> fold_left step (0, 0) |> fst
```

---

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è (Go)

–ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥, –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π OCaml-–≤–∞—Ä–∏–∞–Ω—Ç—É —Å —Ü–∏–∫–ª–∞–º–∏.  
–§—É–Ω–∫—Ü–∏—è `RecurringCycleLen` –≤—ã—á–∏—Å–ª—è–µ—Ç –¥–ª–∏–Ω—É –ø–µ—Ä–∏–æ–¥–∞ —á–µ—Ä–µ–∑ –º–∞—Å—Å–∏–≤ –æ—Å—Ç–∞—Ç–∫–æ–≤, –∞ `LongestCycle` –∏—â–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É.  
–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è **–º—É—Ç–∞–±–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ —Ü–∏–∫–ª–æ–≤**.

---

#### Go-–≤–µ—Ä—Å–∏—è (`go/p26.go`)

```go
package lib

func RecurringCycleLen(d int) int {
	pos := make([]int, d)
	for i := 0; i < d; i++ {
		pos[i] = -1
	}
	remainder := 1 % d
	index := 0
	for remainder != 0 {
		r := remainder % d
		if pos[r] != -1 {
			return index - pos[r]
		}
		pos[r] = index
		remainder = (r * 10) % d
		index++
	}
	return 0
}

func LongestCycle(limit int) int {
	bestD, bestL := 0, 0
	for d := 2; d < limit; d++ {
		l := RecurringCycleLen(d)
		if l > bestL {
			bestL, bestD = l, d
		}
	}
	return bestD
}
```

---

# –û–±—â–∏–µ –≤—ã–≤–æ–¥—ã

–†–∞–±–æ—Ç–∞ –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –±–æ–≥–∞—Ç—Å—Ç–≤–æ –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤ OCaml –∏ –≤–∞–∂–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–≤–æ–π—Å—Ç–≤ –∑–∞–¥–∞—á–∏. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–≤–æ–∏ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á –∏ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π: —Ö–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –±–µ–∑ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ç–µ–∫–∞, –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö —É–ø—Ä–æ—â–∞–µ—Ç –æ—Ç–ª–∞–¥–∫—É, –∞ –º–æ–¥—É–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –ª–µ–≥–∫–æ –∫–æ–º–±–∏–Ω–∏—Ä—É—é—Ç—Å—è –≤ —á–∏—Ç–∞–µ–º—ã–µ –ø–∞–π–ø–ª–∞–π–Ω—ã. –õ–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å Seq —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ —Ä–∞–±–æ—Ç–∞—é—Ç —Å –±–æ–ª—å—à–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏, —ç–∫–æ–Ω–æ–º—è –ø–∞–º—è—Ç—å, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ –∏–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ —Ü–∏–∫–ª—ã –ø—Ä–µ–¥–ª–∞–≥–∞—é—Ç –ø—Ä—è–º–æ–ª–∏–Ω–µ–π–Ω–æ–µ –∏ –±—ã—Å—Ç—Ä–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π.

| –ü–æ–¥—Ö–æ–¥              | –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞                          | –ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏                                 | –ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è                         |
| ------------------- | ------------------------------------- | ------------------------------------------ | ------------------------------------ |
| –ú–æ–Ω–æ–ª–∏—Ç–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏—è | –ü—Ä–æ—Å—Ç–∞—è –∏ –Ω–∞–≥–ª—è–¥–Ω–∞—è                   | –í–æ–∑–º–æ–∂–Ω–æ–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Å—Ç–µ–∫–∞               | –ú–∞–ª—ã–µ –¥–∏–∞–ø–∞–∑–æ–Ω—ã                      |
| –•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è  | –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞ –ø–æ –ø–∞–º—è—Ç–∏, –±–µ–∑ —Ä–æ—Å—Ç–∞ —Å—Ç–µ–∫–∞ | –°–ª–æ–∂–Ω–µ–µ —á–∏—Ç–∞–µ—Ç—Å—è –ø—Ä–∏ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏—è—Ö | –ë–æ–ª—å—à–∏–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏           |
| –ú–æ–¥—É–ª—å–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä  | –ö–æ–º–ø–æ–∑–∏—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–π, –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω–æ—Å—Ç—å   | –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –≤ –ø–∞–º—è—Ç–∏             | –ß–∏—Ç–∞–µ–º—ã–µ –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è    |
| Map/Fold            | –ß–∏—Å—Ç—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å           | –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä            | –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö                 |
| –ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ —Ü–∏–∫–ª—ã  | –ü—Ä–æ—Å—Ç–æ—Ç–∞, –≤—ã—Å–æ–∫–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å  | –ú—É—Ç–∞—Ü–∏–∏, –ø–æ–±–æ—á–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã                  | –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å –ª–∏–Ω–µ–π–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π      |
| –õ–µ–Ω–∏–≤—ã–µ Seq         | –õ–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, —ç–∫–æ–Ω–æ–º–∏—è –ø–∞–º—è—Ç–∏   | –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–ª–∞–¥–∫–∏ –∏ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏            | –ë–æ–ª—å—à–∏–µ/–ø–æ—Ç–æ–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ             |
| Go (–∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ)     | –ü—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç—å, —Å–∫–æ—Ä–æ—Å—Ç—å             | –ú–µ–Ω—å—à–∞—è –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å                    | –ü—Ä–∏–∫–ª–∞–¥–Ω—ã–µ –∏ –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ —Å—Ü–µ–Ω–∞—Ä–∏–∏ |

---

## üìà –†–µ–∑—É–ª—å—Ç–∞—Ç—ã

–û–±–µ –∑–∞–¥–∞—á–∏ Project Euler (‚Ññ4 –∏ ‚Ññ26) –±—ã–ª–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–µ—à–µ–Ω—ã –≤—Å–µ–º–∏ —Å–ø–æ—Å–æ–±–∞–º–∏,  
—á—Ç–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ —Ç–µ—Å—Ç–∞–º–∏ –∏ CI-–ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏ –Ω–∞ GitHub Actions.

| –ó–∞–¥–∞—á–∞                          | –†–µ–∑—É–ª—å—Ç–∞—Ç  | –Ø–∑—ã–∫       | –ú–µ—Ç–æ–¥—ã                     |
| ------------------------------- | ---------- | ---------- | -------------------------- |
| ‚Ññ4 ‚Äî Largest Palindrome Product | **906609** | OCaml / Go | Tail Recursion, Loops, Seq |
| ‚Ññ26 ‚Äî Reciprocal Cycles         | **983**    | OCaml / Go | Map/Fold, Seq, Loops       |

---

**–ò–¢–ú–û, 2025**
